# Memory-Pool
An easy to use and efficient memory pool allocator written in C++.

## 项目介绍
 - 内存池是池化技术中的一种形式。通常在编写程序的时候会使用 new delete 这些关键字来向操作系统申请内存，而这样造成的后果就是每次申请内存和释放内存的时候，都需要和操作系统的系统调用打交道，从堆中分配所需的内存。如果这样的操作太过频繁，就会找成大量的内存碎片进而降低内存的分配性能，甚至出现内存分配失败的情况。
- 而内存池就是为了解决这个问题而产生的一种技术。从内存分配的概念上看，内存申请无非就是向内存分配方索要一个指针，当向操作系统申请内存时，操作系统需要进行复杂的内存管理调度之后，才能正确的分配出一个相应的指针。而这个分配的过程中还面临着分配失败的风险。
- 所以，每一次进行内存分配，就会消耗一次分配内存的时间，设这个时间为 T，那么进行 n 次分配总共消耗的时间就是 nT；如果一开始就确定好可能需要多少内存，那么在最初的时候就分配好这样的一块内存区域，当我们需要内存的时候，直接从这块已经分配好的内存中使用即可，那么总共需要的分配时间仅仅只有 T。当 n 越大时，节约的时间就越多。

## 项目相关
- C++11 特性
- C++ 中的内存分配器 std::allocator
- 内存池技术
- 手动实现模板链式栈
- 链式栈和列表栈的性能比较

## 性能对比
- 使用默认分配器的链表栈速度最慢，其次是使用项目实现的内存池，最后，对于vector消耗的时间最少（在链表栈的基础上大幅度削减了时间）。
- ![测试](https://github.com/Aurorayqz/Memory-Pool/blob/master/test.png);
- std::vector 的实现方式其实和内存池较为类似，在 std::vector 空间不够用时，会抛弃现在的内存区域重新申请一块更大的区域，并将现在内存区域中的数据整体拷贝一份到新区域中。
- 注意，性能测试是在频繁分配和释放固定大小对象的情况下进行
- 假如要求自动管理多种不同大小内存块并可以自动增长的内存池，显然allocator（STL 中的内存分配器）更适合。
